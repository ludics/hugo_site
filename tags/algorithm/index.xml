<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Carpe Diem</title>
    <link>https://ludics.github.io/tags/algorithm/</link>
    <description>Recent content in Algorithm on Carpe Diem</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>leonludics@gmail.com (Lu Di)</managingEditor>
    <webMaster>leonludics@gmail.com (Lu Di)</webMaster>
    <lastBuildDate>Sat, 13 Apr 2019 01:04:00 +0800</lastBuildDate>
    
	<atom:link href="https://ludics.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Min Jump</title>
      <link>https://ludics.github.io/post/min_jump/</link>
      <pubDate>Sat, 13 Apr 2019 01:04:00 +0800</pubDate>
      <author>leonludics@gmail.com (Lu Di)</author>
      <guid>https://ludics.github.io/post/min_jump/</guid>
      <description>页面最小跳转次数 电商网站中，web页面之间可以互相跳转。给定用户路径中的起始页面和终点页面，计算用户路径中，这两个页面间最少需要经过的跳转次数。
请使用标准输入输出(stdin，stdout)；请把所有程序写在一个文件里，勿使用已禁用图形、文件、网络、系统相关的头文件和操作，如sys/stat.h , unistd.h , curl/curl.h , process.h
时间限制: 1S (C/C++以外的语言为: 3 S)
内存限制: 64M (C/C++以外的语言为: 576 M)
输入:
第一行包含两列，为起始页面和终止页面的名称。 第二行到最后一行为用户行为日志，其中第一列为当前页面名称，第二列为上一页面名称。第二行的NULL表示第一个页面的上级页面为空。每列数据之间以逗号&amp;rsquo;,&amp;lsquo;为分隔符，具体请见输入范例。
输出:
上述用户的行为路径中，页面A到页面F有以下两种方式
 A-&amp;gt;B-&amp;gt;D-&amp;gt;E-&amp;gt;F A-&amp;gt;E-&amp;gt;F  此时方式2跳转次数最少，为2
输入范例:
A,F A,NULL B,A D,B F,B E,A F,E E,D D,B C,B B,G G,F C,F  输出范例:
2  Python解法 l=[[&amp;#34;A&amp;#34;,&amp;#34;F&amp;#34;], [&amp;#34;A&amp;#34;,&amp;#34;NULL&amp;#34;], [&amp;#34;B&amp;#34;,&amp;#34;A&amp;#34;], [&amp;#34;D&amp;#34;,&amp;#34;B&amp;#34;], [&amp;#34;F&amp;#34;,&amp;#34;B&amp;#34;], [&amp;#34;E&amp;#34;,&amp;#34;A&amp;#34;], [&amp;#34;F&amp;#34;,&amp;#34;E&amp;#34;], [&amp;#34;E&amp;#34;,&amp;#34;D&amp;#34;], [&amp;#34;D&amp;#34;,&amp;#34;B&amp;#34;], [&amp;#34;C&amp;#34;,&amp;#34;B&amp;#34;], [&amp;#34;B&amp;#34;,&amp;#34;G&amp;#34;], [&amp;#34;G&amp;#34;,&amp;#34;F&amp;#34;], [&amp;#34;C&amp;#34;,&amp;#34;F&amp;#34;]] start=l[0][0] target=l[0][1] l=l[1:] l1=[] def f(start,target,m=0): for i in range(len(l)): if l[i][1]==start and l[i][0]==target: return m+1 if l[i][1]==start and l[i][0]!</description>
    </item>
    
  </channel>
</rss>